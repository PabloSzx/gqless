import { ListType, ObjectType, SchemaType } from '../Schema'
import _ from 'lodash'

export const CORE = 'gqless'
export const UTILS = '@gqless/utils'

export abstract class File {
  constructor(public path: string, public overwrite: boolean = true) {}

  private imports = new Map<string, Set<string>>()
  private importAlls = new Map<string, string>()

  protected import(from: string, ...imports: string[]) {
    if (!this.imports.has(from)) this.imports.set(from, new Set())
    const importsSet = this.imports.get(from)!
    imports.forEach(imp => importsSet.add(imp))
  }

  protected importAll(from: string, as: string) {
    if (this.importAlls.has(from)) {
      const existingName = this.importAlls.get(from)
      if (existingName !== as)
        throw new Error(
          `Already imported all from ${from}, use ${existingName} instead of ${as}`
        )

      return
    }

    this.importAlls.set(from, as)
  }

  public generate() {
    return [
      this.overwrite &&
        `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n`,
      ...Array.from(this.importAlls.entries()).map(
        ([from, as]) => `import * as ${as} from '${from}'`
      ),
      ...Array.from(this.imports.entries()).map(([from, imports]) =>
        imports.size
          ? `import { ${Array.from(imports).join(',')} } from '${from}'`
          : ''
      ),
    ]
      .filter(Boolean)
      .join('\n')
  }

  protected generateComments(comments: string[]) {
    if (comments.length) {
      const text = comments.join('\n* ').replace(/\*\//gm, '*\u200B/')
      return (
        `\n` + `/**${comments.length > 1 ? `\n * ${text}\n` : ` ${text}`} */\n`
      )
    }

    return ''
  }

  protected generateTypeComments(type: SchemaType, includeName?: boolean) {
    const comments: string[] = [`@kind ${_.upperFirst(_.camelCase(type.kind))}`]

    if (includeName) {
      comments.unshift(`@typename ${type.name}`)
    }

    if (type.kind === 'OBJECT' && type.interfaces.length) {
      comments.push(`@implements ${type.interfaces.join(', ')}`)
    }

    return this.generateComments(comments)
  }

  protected generateRef(
    type: ListType | { name: string; nullable?: boolean },
    quote = true
  ): string {
    let value: string
    if ('kind' in type && type.kind === 'LIST') {
      value = `[${this.generateRef(type.ofType, false)}]${
        type.nullable ? '' : '!'
      }`
    } else {
      value = `${(type as ObjectType).name}${type.nullable ? '' : '!'}`
    }

    return quote ? JSON.stringify(value) : value
  }
}
